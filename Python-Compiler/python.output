Nonterminals useless in grammar

    expr
    exprList
    exprListEmpty
    idList
    body
    elseStmt
    forStmt
    whileStmt
    ifStmt
    elifStmt
    elifStmtList
    tryStmt
    exceptStmt
    exceptStmtList
    finallyStmt


Terminals unused in grammar

    FOR
    WHILE
    IN
    IF
    ELSE
    ELIF
    TRY
    EXCEPT
    FINALLY
    ID
    NEWLINE
    INDENT
    DEDENT
    INT
    FLOAT
    COMPLEX
    TRUE
    FALSE
    STR
    NONE
    '='
    PLUS_ASSIGN
    MINUS_ASSIGN
    MULT_ASSIGN
    DEGREE_ASSIGN
    DIV_ASSIGN
    MOD_ASSIGN
    AND
    OR
    NOT
    '+'
    '-'
    '*'
    '/'
    '%'
    FLOOR_DIV
    DEGREE
    '<'
    LESSER_EQUAL
    '>'
    GREATER_EQUAL
    NOT_EQUAL
    EQUAL
    ','
    ':'


Rules useless in grammar

    2 expr: ID
    3     | INT
    4     | FLOAT
    5     | COMPLEX
    6     | TRUE
    7     | FALSE
    8     | STR
    9     | NONE
   10     | expr '+' expr
   11     | expr '-' expr
   12     | expr '*' expr
   13     | expr '/' expr
   14     | expr FLOOR_DIV expr
   15     | expr '%' expr
   16     | expr DEGREE expr
   17     | '+' expr
   18     | '-' expr
   19     | expr '=' expr
   20     | expr PLUS_ASSIGN expr
   21     | expr MINUS_ASSIGN expr
   22     | expr MULT_ASSIGN expr
   23     | expr DEGREE_ASSIGN expr
   24     | expr DIV_ASSIGN expr
   25     | expr MOD_ASSIGN expr
   26     | expr AND expr
   27     | expr OR expr
   28     | expr NOT expr
   29     | expr '<' expr
   30     | expr LESSER_EQUAL expr
   31     | expr '>' expr
   32     | expr GREATER_EQUAL expr
   33     | expr NOT_EQUAL expr
   34     | expr EQUAL expr

   35 exprList: exprList ',' expr
   36         | expr

   37 exprListEmpty: exprList
   38              | %empty

   39 idList: ID
   40       | idList ',' ID

   41 body: expr
   42     | NEWLINE INDENT exprList DEDENT

   43 elseStmt: ELSE ':' expr
   44         | ELSE ':' body

   45 forStmt: FOR idList IN expr ':' body elseStmt
   46        | FOR idList IN expr ':' body

   47 whileStmt: WHILE expr ':' body elseStmt
   48          | WHILE expr ':' body

   49 ifStmt: IF expr ':' expr
   50       | IF expr ':' body
   51       | IF expr ':' body elseStmt
   52       | IF expr ':' body elifStmtList
   53       | IF expr ':' body elifStmtList elseStmt

   54 elifStmt: ELIF ':' expr
   55         | ELIF ':' body

   56 elifStmtList: elifStmt
   57             | elifStmtList elifStmt

   58 tryStmt: TRY ':' expr
   59        | TRY ':' body
   60        | TRY ':' body elseStmt
   61        | TRY ':' body exceptStmtList
   62        | TRY ':' body exceptStmtList elseStmt
   63        | TRY ':' body exceptStmtList finallyStmt
   64        | TRY ':' body exceptStmtList finallyStmt elseStmt

   65 exceptStmt: EXCEPT ':' expr
   66           | EXCEPT ':' body

   67 exceptStmtList: exceptStmt
   68               | exceptStmtList exceptStmt

   69 finallyStmt: FINALLY ':' expr
   70            | FINALLY ':' body


Grammar

    0 $accept: program $end

    1 program: %empty


Terminals, with rules where they appear

    $end (0) 0
    '%' (37)
    '*' (42)
    '+' (43)
    ',' (44)
    '-' (45)
    '/' (47)
    ':' (58)
    '<' (60)
    '=' (61)
    '>' (62)
    error (256)
    FOR (258)
    WHILE (259)
    IN (260)
    IF (261)
    ELSE (262)
    ELIF (263)
    TRY (264)
    EXCEPT (265)
    FINALLY (266)
    ID (267)
    NEWLINE (268)
    INDENT (269)
    DEDENT (270)
    INT (271)
    FLOAT (272)
    COMPLEX (273)
    TRUE (274)
    FALSE (275)
    STR (276)
    NONE (277)
    PLUS_ASSIGN (278)
    MINUS_ASSIGN (279)
    MULT_ASSIGN (280)
    DEGREE_ASSIGN (281)
    DIV_ASSIGN (282)
    MOD_ASSIGN (283)
    AND (284)
    OR (285)
    NOT (286)
    FLOOR_DIV (287)
    UPLUS (288)
    UMINUS (289)
    DEGREE (290)
    LESSER_EQUAL (291)
    GREATER_EQUAL (292)
    NOT_EQUAL (293)
    EQUAL (294)


Nonterminals, with rules where they appear

    $accept (50)
        on left: 0
    program (51)
        on left: 1
        on right: 0


State 0

    0 $accept: . program $end

    $default  reduce using rule 1 (program)

    program  go to state 1


State 1

    0 $accept: program . $end

    $end  shift, and go to state 2


State 2

    0 $accept: program $end .

    $default  accept
